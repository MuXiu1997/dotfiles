#!/usr/bin/env python3
import functools
import os.path
import subprocess

COMPLETIONS_DIR = os.path.join(os.path.expanduser('~'), '.config', 'zsh', 'completions')


class Command:
    def __init__(self, command, version_command, version_func, completion_func):
        """
        :type command: str
        :type version_command: list[str]
        :type version_func: function
        :type completion_func: function
        """
        self.command = command
        self.version_command = version_command
        self.version_func = version_func
        self.completion_func = completion_func

    @functools.cached_property
    def exist(self):
        return subprocess.run(
            ['type', self.command],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            check=False,
        ).returncode == 0

    @functools.cached_property
    def completion_version_filepath(self):
        return os.path.join(COMPLETIONS_DIR, '.{}-version'.format(self.command))

    @functools.cached_property
    def completion_filepath(self):
        return os.path.join(COMPLETIONS_DIR, '_{}'.format(self.command))

    @functools.cached_property
    def completion_version(self):
        try:
            with open(self.completion_version_filepath, mode='r') as fp:
                return fp.read()
        except:
            return None

    @functools.cached_property
    def version(self):
        version_output = subprocess.run(
            [self.command, *self.version_command],
            capture_output=True,
        ).stdout.strip().decode()
        return self.version_func(version_output)

    @functools.cached_property
    def need_to_be_updated(self):
        return self.version != self.completion_version

    def update(self):
        self.completion_func(self.version, self.completion_filepath)
        with open(self.completion_version_filepath, mode='w') as fp:
            fp.write(self.version)

    def check_and_update(self):
        if self.need_to_be_updated:
            self.update()


PROXY_ENV = {
    'ALL_PROXY': 'socks5://127.0.0.1:1080'
}
proxy_enabled = subprocess.run(
    ['curl', 'cip.cc'],
    check=False,
    env=PROXY_ENV,
    stdout=subprocess.DEVNULL,
    stderr=subprocess.DEVNULL,
).returncode == 0


def write_file(content, path):
    with open(path, mode='w') as fp:
        fp.write(content)


def download(url, path):
    content = subprocess.run(
        ['curl', url],
        env=PROXY_ENV if proxy_enabled else None,
        capture_output=True,
    ).stdout.decode()

    write_file(content, path)


def write_output(process, path):
    content = process.stdout.decode()

    write_file(content, path)


if __name__ == '__main__':
    import re

    commands = [
        Command(
            'docker',
            ['--version'],
            lambda o: re.search('version (.*?),', o)[1],
            lambda v, p: download(
                'https://raw.githubusercontent.com/docker/cli/v{}/contrib/completion/zsh/_docker'.format(v),
                p,
            ),
        ),
        Command(
            'docker-compose',
            ['--version'],
            lambda o: re.search('version (.*?),', o)[1],
            lambda v, p: download(
                'https://raw.githubusercontent.com/docker/compose/{}/contrib/completion/zsh/_docker-compose'.format(v),
                p,
            ),
        ),
        Command(
            'bw',
            ['--version'],
            lambda o: o,
            lambda v, p: write_output(
                subprocess.run(['bw', 'completion', '--shell', 'zsh'], capture_output=True),
                p,
            )
        )
    ]

    for c in commands:
        c.check_and_update()
