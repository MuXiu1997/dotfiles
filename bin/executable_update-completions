#!/usr/bin/env python3
import functools
import os.path
import socket
import subprocess

XDG_DATA_HOME = os.environ.get('XDG_DATA_HOME')
COMPLETIONS_DIR = os.path.join(XDG_DATA_HOME, 'zsh', 'site-functions')

os.makedirs(COMPLETIONS_DIR, exist_ok=True)


class Command:
    def __init__(self, command, version_command, version_func, completion_func):
        """
        :type command: str
        :type version_command: list[str]
        :type version_func: function
        :type completion_func: function
        """
        self.command = command
        self.version_command = version_command
        self.version_func = version_func
        self.completion_func = completion_func

    @functools.cached_property
    def exist(self):
        return subprocess.run(
            ['type', self.command],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            check=False,
        ).returncode == 0

    @functools.cached_property
    def completion_version_filepath(self):
        return os.path.join(COMPLETIONS_DIR, '.{}-version'.format(self.command))

    @functools.cached_property
    def completion_filepath(self):
        return os.path.join(COMPLETIONS_DIR, '_{}'.format(self.command))

    @functools.cached_property
    def completion_version(self):
        try:
            with open(self.completion_version_filepath, mode='r') as fp:
                return fp.read()
        except:
            return None

    @functools.cached_property
    def version(self):
        version_output = subprocess.run(
            [self.command, *self.version_command],
            capture_output=True,
        ).stdout.strip().decode()
        return self.version_func(version_output)

    @functools.cached_property
    def need_to_be_updated(self):
        return self.version != self.completion_version

    def update(self):
        self.completion_func(self.version, self.completion_filepath)
        with open(self.completion_version_filepath, mode='w') as fp:
            fp.write(self.version)

    def check_and_update(self):
        if self.need_to_be_updated:
            self.update()


PROXY_ENV = {
    'ALL_PROXY': 'socks5://127.0.0.1:1080'
}
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect_ex(('127.0.0.1', 1080))
proxy_enabled = s.connect_ex(('127.0.0.1', 1080)) == 0
s.close()


def write_file(content, path):
    with open(path, mode='w') as fp:
        fp.write(content)


def download(url, path):
    content = subprocess.run(
        ['curl', url],
        env=PROXY_ENV if proxy_enabled else None,
        capture_output=True,
    ).stdout.decode()

    write_file(content, path)


def write_output(process, path):
    content = process.stdout.decode()
    write_file(content, path)


def cp(source_path, target_path):
    with open(source_path, mode='r') as source_fp:
        write_file(source_fp.read(), target_path)


if __name__ == '__main__':
    import re

    commands = [
        Command(
            'bw',
            ['--version'],
            lambda o: o,
            lambda v, p: write_output(
                subprocess.run(['bw', 'completion', '--shell', 'zsh'], capture_output=True),
                p,
            )
        ),
    ]

    for c in commands:
        c.check_and_update()
